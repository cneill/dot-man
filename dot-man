#!/bin/bash
################################################################################
# dot-man
#
# Copyright (c) 2015 Charles Neill
# Github: cneill | Twitter: ccneill
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#   1. Redistributions of source code must retain the above copyright notice,
#      this list of conditions and the following disclaimer.
#   2. Redistributions in binary form must reproduce the above copyright notice,
#      this list of conditions and the following disclaimer in the documentation
#      and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
################################################################################
platform="unknown"
config_file=$HOME/.dotfiles
editor=${EDITOR:-vi}
ARGS=("$@")
# Command line arguments
HELP=0
IGNORE_LAST_RUN=0
CHECK_LAST_RUN=0
LOAD_UNSAFE_CONFIG=0
LAZY_PLATFORM_DETECT=0
VERBOSE=0
# Colors / formatting
sep="\033[31m================================================================================\033[0m"
banner="$sep\ndot-man (•‿•)%67s\n$sep"
b="\033[1m"
b_="\033[0m"
hi="${b}\033[92m"
hi_="\033[0m${b_}"
f="\033[4m\033[34m"
f_="\033[0m\033[24m"

# Load our configuration file
function load_config {
    if [[ $LOAD_UNSAFE_CONFIG == 1 ]]; then
        . $config_file
    fi
    clean=`grep -vE '(^[# a-zA-Z]$)|(^[a-z]+=[a-z" ]$)' $config_file`
    if [[ ! -z $clean ]] && [[ $LOAD_UNSAFE_CONFIG == 0 ]]; then
        echo -e "Warning: your configuration file may have unsafe lines in it. \n${b}What would you like to do?${b_} [c]ontinue, [o]pen, or [${hi}Q${hi_}]uit:"
        read -p "  > " continue_reading
        if [[ $continue_reading == "c" ]] || [[ $continue_reading == "C" ]]; then
            . $config_file
        elif [[ $continue_reading == "o" ]] || [[ $continue_reading == "O" ]]; then
            $editor $config_file
            echo -e "${b}Continue loading configuration file?${b_} [y/${hi}N${hi_}]"
            read -p "  > " continue_loading
            if [[ $continue_loading == "y" ]] || [[ $continue_loading == "Y" ]]; then
                . $config_file
            else
                echo "Unable to load configuration. Quitting."
                exit -1
            fi
        else
            echo "Quitting."
            exit 0
        fi
    fi
}

# See when we last ran dot-man
function check_last_run {
    thedate=`date`
    thetime=""
    pretty_last_time=""
    if [[ $platform == "Linux" ]]; then
        thetime=`date -d "$thedate" "+%s"`
    elif [[ $platform == "OS X" ]]; then
        thetime=`date -j -f "%a %b %d %T %Z %Y" "$thedate" "+%s"`
    fi
    if [[ -f $dotfiles_last_run_file ]]; then
        raw=`cat $dotfiles_last_run_file`
        if [[ $platform == "Linux" ]]; then
            last_time=`date -d "@$raw"`
        elif [[ $platform == "OS X" ]]; then
            last_time=`date -r $raw`
        fi
        time_diff=`expr $thetime - $raw`
        if [[ $CHECK_LAST_RUN == 1 ]]; then
            if [[ $time_diff -lt $dotfiles_update_interval ]]; then
                exit 0
            else
                echo "$thetime" > $dotfiles_last_run_file
            fi
        else
            echo -e "Last run: $last_time.\n${b}Continue?${b_} [y/${hi}N${hi_}]"
            read -p "  > " continue_running
            if [[ $continue_running != "y" ]] && [[ $continue_running != "Y" ]]; then
                echo "Quitting."
                exit 0
            else
                echo "$thetime" > $dotfiles_last_run_file
            fi
        fi
    else
        touch $dotfiles_last_run_file
        echo "$thetime" > $dotfiles_last_run_file
    fi

}

# check to make sure we have the right platform
function check_platform {
    unamestr=`uname`
    
    if [[ $unamestr == "Linux" ]]; then
        platform="Linux"
    elif [[ $unamestr == "Darwin" ]]; then
        platform="OS X"
    fi


    if [[ $platform != "unknown" ]]; then
        if [[ -z $dotfiles_branch ]]; then
            if [[ $platform == "Linux" ]]; then
                dotfiles_branch="linux"
            elif [[ $platform == "OS X" ]]; then
                dotfiles_branch="osx"
            fi
        elif [[ $VERBOSE == 1 ]]; then
            echo "Using branch $dotfiles_branch (defined in $config_file)."
        fi

        if [[ $LAZY_PLATFORM_DETECT == 0 ]]; then
            echo -e "It looks like your platform is $platform.\n${b}Is this correct?${b_} [y/${hi}N${hi_}]"
            read -p "  > " correct_platform
            if [[ $correct_platform != "y" ]] && [[ $correct_platform != "Y" ]]; then
                echo "Unknown platform. Quitting."
                exit -1
            fi
        fi
    else
        echo "Unknown platform. Quitting."
        exit -1
    fi

}

# check to see if our dotfiles folder exists
function check_dotfiles_exist {
    echo -e "Checking dotfiles exist...\n"
    

    if [[ ! -d $dotfiles_repo_loc ]]; then
        if [[ -e $dotfiles_repo_loc ]]; then
            echo -e "${f}$dotfiles_repo_loc${f_} is not a directory.\nDelete and create directory? [y/${hi}N${hi_}]"
            read -p " > " delete_file
            if [[ $delete_file == "y" ]] || [[ $delete_file == "Y" ]]; then
                rm -rf $dotfiles_repo_loc
                mkdir $dotfiles_repo_loc
            else
                echo -e "Can't continue without a valid \$dotfiles_repo_loc."
                exit -1
            fi
        else
            echo -e "No folder named $dotfiles_repo_loc.\nCreate directory ${f}$dotfiles_repo_loc${f_}? [y/${hi}N${hi_}]"
            read -p " > " create_directory
            if [[ $create_directory == "y" ]] || [[ $create_directory == "Y" ]]; then
                mkdir $dotfiles_repo_loc
            else
                echo -e "Can't continue without a valid \$dotfiles_repo_loc."
                exit -1
            fi
        fi
    fi

    if [[ ! -z $(git -C $dotfiles_repo_loc status 2>&1 | fgrep 'Not a git repository') ]]; then
        echo -e "Git repository not found at this location.\n${b}Initialize one or clone?${b_}\n[i]nitialize, [c]lone, or [${hi}Q${hi_}]uit: "
        read -p "  > " initialize_git

        if [[ $initialize_git == "i" ]] || [[ $initialize_git == "I" ]]; then
            git -C $dotfiles_repo_loc init
            git -C $dotfiles_repo_loc checkout -b $dotfiles_branch
        elif [[ $initialize_git == "c" ]] || [[ $initialize_git == "C" ]]; then
            is_dirty=`ls $dotfiles_repo_loc`
            if [[ ! -z $is_dirty ]]; then
                echo -e "Existing files in ${f}$dotfiles_repo_loc${f_}:\n$is_dirty\n\n${b}Delete files?${b_} [y/${hi}N${hi_}]" 
                read -p "  > " delete_existing
                if [[ $delete_existing == "y" ]] || [[ $delete_existing == "Y" ]]; then
                    rm -rf $dotfiles_repo_loc
                    mkdir $dotfiles_repo_loc
                else
                    echo -e "Cannot clone repository without deleting files in ${f}$dotfiles_repo_loc${f_}. Clean up this directory and try again."
                    exit -1
                fi
            fi
            git clone $dotfiles_repo $dotfiles_repo_loc
            git -C $dotfiles_repo_loc checkout -b $dotfiles_branch
        else
            echo "Quitting."
            exit -1
        fi
    else
        echo "Found dotfiles repository."
    fi
}

# update dotfiles repository from remote
function update_dotfiles {
    echo -e "Checking status of repository...\n"
    current_branch=`git -C $dotfiles_repo_loc status | grep "On branch " | sed "s/On branch //"`
    if [[ $current_branch != $dotfiles_branch ]]; then
        git -C $dotfiles_repo_loc checkout $dotfiles_branch
        git -C $dotfiles_repo_loc branch -u "origin/$dotfiles_branch"
    fi
    git -C $dotfiles_repo_loc remote update
    status=$(git -C $dotfiles_repo_loc status)
    up_to_date=`grep "Your branch is up-to-date" <<< $status` 
    up_to_date2=`grep -E "nothing (added )*to commit" <<< $status` # Dirty branch is thrown away here. Maybe we want to update?
    
    if [[ $up_to_date ]] || [[ $up_to_date2 ]]; then
        echo "Local repository is up-to-date with remote repository."
    else
        echo -e "The dotfiles repository has been updated, or has unstaged changes.\n${b}Pull latest version?${b_} [y/${hi}N${hi_}]"
        read -p "  > " pull_latest
        if [[ $pull_latest == "y" ]] || [[ $pull_latest == "Y" ]]; then
            git -C $dotfiles_repo_loc pull -u origin $dotfiles_branch
        else
            echo "Not updating repository from remote."
        fi
    fi
}

# diff directories and copy any updates
function compare_dotfiles {
    echo -e "Comparing files from ${f}$dotfiles_repo_loc${f_} with files in ${f}$dotfiles_home${f_}.\n"
    for file in `git -C $dotfiles_repo_loc ls-files`; do
        if [[ $file != "$dotfiles_repo_loc/." ]] && [[ $file != "$dotfiles_repo_loc/.." ]] && [[ $file != ".git" ]] && [[ $file != ".gitignore" ]]; then
            if [[ $dotfiles_repo_loc/$file -nt $dotfiles_home/$file ]]; then
                if [[ ! -f $dotfiles_home/$file ]]; then
                    echo -e "File ${f}$file${f_} doesn't exist in ${f}$dotfiles_home${f_}.\n${b}Copy from repo?${b_} [y/${hi}N${hi_}]"
                    read -p "  > " copy_straight
                    if [[ $copy_straight == "y" ]] || [[ $copy_straight == "Y" ]]; then
                        cp $dotfiles_repo_loc/$file $dotfiles_home/$file
                    fi
                else 
                    difference=`diff $dotfiles_repo_loc/$file $dotfiles_home/$file`
                    if [[ ! -z $difference ]]; then
                        echo -e "Dotfiles repository has newer version of ${f}$file${f_}.\n${b}Open sdiff?${b_} [y/${hi}N${hi_}]"
                        read -p "  > " open_sdiff
                        if [[ $open_sdiff == "y" ]] || [[ $open_sdiff == "Y" ]]; then
                            outfile=`mktemp TEMP_DOTFILE.XXXXXXXXXX`
                            sdiff -o $outfile $dotfiles_repo_loc/$file $dotfiles_home/$file
                            cp $outfile $dotfiles_home/$file
                            rm $outfile 
                        fi
                    elif [[ $VERBOSE == 1  ]]; then
                        echo "${f}$file${f_} is up-to-date!"
                    fi
                fi
            elif [[ $dotfiles_home/$file -nt $dotfiles_repo_loc/$file ]]; then
                difference=`diff $dotfiles_home/$file $dotfiles_repo_loc/$file`
                if [[ ! -z $difference ]]; then
                    echo -e "$sep\nDifferences found in ${f}$dotfiles_home/$file${f_}.\n${b}Open sdiff?${b_} [y/${hi}N${hi_}]"
                    read -p "  > " open_sdiff
                    if [[ $open_sdiff == "y" ]] || [[ $open_sdiff == "Y" ]]; then
                        outfile=`mktemp TEMP_DOTFILE.XXXXXXXXXX`
                        sdiff -o $outfile $dotfiles_home/$file $dotfiles_repo_loc/$file
                        home_difference=`diff $outfile $dotfiles_home/$file`
                        repo_difference=`diff $outfile $dotfiles_repo_loc/$file`
                        if [[ ! -z $home_difference ]]; then
                            echo -e "${b}Copy to $dotfiles_home?${b_} [y/${hi}N${hi_}]"
                            read -p "  > " copy_home 
                            if [[ $copy_home == "y" ]] || [[ $copy_home == "Y" ]]; then
                                cp $outfile $dotfiles_home/$file
                            fi
                        fi
                        if [[ ! -z $repo_difference ]]; then
                            echo -e "${b}Copy to $dotfiles_repo_loc? [y/${hi}N${hi_}]${b_}"
                            read -p "  > " copy_dotfiles
                            if [[ $copy_dotfiles == "y" ]] || [[ $copy_dotfiles == "Y" ]]; then
                                cp $outfile $dotfiles_repo_loc/$file
                                echo -e "${b}Update dotfiles repository?${b_} [y/${hi}N${hi_}]"
                                read -p "  > " update_dotfiles
                                if [[ $update_dotfiles == "y" ]] || [[ $update_dotfiles == "Y" ]]; then
                                    git -C $dotfiles_repo_loc add $dotfiles_repo_loc/$file
                                    commit_message="Updating $file on `hostname` at `date`."
                                    echo -e "${b}Custom commit message?${b_} [y/${hi}N${hi_}]"
                                    read -p "  > " custom_commit
                                    if [[ $custom_commit == "y" ]] || [[ $custom_commit == "Y" ]]; then
                                        echo "Enter commit message: "
                                        read -p "  > " custom_commit_message
                                        commit_message=$custom_commit_message
                                    fi
                                    git -C $dotfiles_repo_loc commit -m "$commit_message" -q
                                    git -C $dotfiles_repo_loc push -u $dotfiles_repo
                                    echo "Pushed updates to $dotfiles_repo!"
                                fi
                            fi
                        fi
                        rm $outfile 
                    else
                        echo "Leaving differences in ${f}$file${f_} unchanged."
                    fi
                elif [[ $VERBOSE == 1 ]]; then
                    echo "${f}$file${f_} is up-to-date!"
                fi
            fi
        fi
    done
    echo "Finished with all dotfiles!"
}

for arg in "$@"; do
    case $arg in
        -h)
            HELP=1
            IGNORE_LAST_RUN=1
        ;;
        -d)
            LAZY_PLATFORM_DETECT=1
        ;;
        -f)
            LOAD_UNSAFE_CONFIG=1
        ;;
        -i)
            IGNORE_LAST_RUN=1
        ;;
        -l)
            CHECK_LAST_RUN=1
        ;;
        -v)
            VERBOSE=1
        ;;
    esac
done

if [[ $HELP == 1 ]]; then
    echo -e "Usage:\n
    $(basename "$0") [-h] [-d] [-f] [-i] [-l] [-v]
    \nOptions:\n
    \t-h\tShow this help message
    \t-d\tUse best guess for platform
    \t-f\tForce auto-load of config file (no check for unsafe values)
    \t-i\tIgnore last run check entirely
    \t-l\tDon't check for updates unless it's been \$dotfiles_update_interval seconds since last run
    \t-v\tVerbose: print more information"
    exit
fi

load_config
check_platform
printf "$banner\n" "$USER@$(hostname):$dotfiles_branch"
if [[ $IGNORE_LAST_RUN == 0 ]]; then
    check_last_run
fi

check_dotfiles_exist
echo -e $sep
update_dotfiles
echo -e $sep
compare_dotfiles
echo -e $sep
